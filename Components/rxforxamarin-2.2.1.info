{"Name":"Reactive Extensions (Rx) for Xamarin","Id":1363,"Alias":"rxforxamarin","Description":"Reactive Extensions (Rx) is a library for composing asynchronous\r\nand event-based programs using observable sequences and LINQ-style\r\nquery operators. Using Rx, developers represent asynchronous data\r\nstreams with `Observables`, query asynchronous data streams using LINQ\r\noperators, and parameterize the concurrency in the asynchronous data\r\nstreams using `Schedulers`. Simply put, Rx = Observables + LINQ +\r\nSchedulers.\r\n\r\nWhether you are authoring a traditional desktop or web-based\r\napplication, you have to deal with asynchronous and event-based\r\nprogramming from time to time. Desktop applications have I/O\r\noperations and computationally expensive tasks that might take a long\r\ntime to complete and potentially block other active\r\nthreads. Furthermore, handling exceptions, cancellation, and\r\nsynchronization is difficult and error-prone.\r\n\r\nUsing Rx, you can represent multiple asynchronous data streams that\r\ncome from diverse sources, e.g., stock quotes, tweets, computer events,\r\nweb service requests, etc., and subscribe to the event stream using\r\nthe `IObserver\u003cT\u003e` interface. The `IObservable\u003cT\u003e` interface notifies the\r\nsubscribed `IObserver\u003cT\u003e` interface whenever an event occurs.\r\n\r\nBecause observable sequences are data streams, you can query them\r\nusing standard LINQ query operators implemented by the Observable\r\nextension methods. Thus you can filter, project, aggregate, compose\r\nand perform time-based operations on multiple events easily by using\r\nthese standard LINQ operators. In addition, there are a number of\r\nother reactive stream specific operators that allow powerful queries\r\nto be written.  Cancellation, exceptions, and synchronization are also\r\nhandled gracefully by using the extension methods provided by Rx.\r\n\r\nTo learn more about the Reactive Extensions, see Microsoft\u0027s \r\nRX open source site:\r\n\r\n   http://rx.codeplex.com\r\n\r\n## Current Version\r\n\r\n*\tcurrent version supports \r\n\t*\tRx.net v.2.2\r\n\t*\tiOS Unified and Classic API\r\n\t","Version":"2.2.1","Summary":"Create async and event based apps using observable sequences \u0026 LINQstyle queries","QuickStart":"Rx is published as an open source project and you can pick up sources from CodePlex (http://rx.codeplex.com). There is a dedicated web page section for Rx on MSDN website too: http://msdn.microsoft.com/en-us/data/gg577609.aspx\r\n\r\nThis component contains Rx libraries that are suited for Xamarin.Android and Xamarin.iOS.\r\n\r\n# Adjusting Library References\r\n\r\nAfter adding this component to your project, you would notice that there are several dlls in this package. You would however most likely need to use the following four assemblies:\r\n\r\n* System.Reactive.Interfaces.dll\r\n* System.Reactive.Core.dll\r\n* System.Reactive.Linq.dll\r\n* System.Reactive.PlatformServices.dll\r\n\r\nAll other assemblies are optional and you would like to use them only in certain scenarios. On the other hand, those four assemblies are essential. So far let\u0027s remove other assemblies in this package.\r\n\r\n\r\n\r\n(Note that Rx version 2.x is very different from Rx v1.0 in terms of assemblies; Rx 1.0 consists only of System.Reactive.dll, which does not exist in Rx v2.x.)\r\n\r\n# Sample: Transforming touch events into another event\r\n\r\nHere we show an example use of `Observable.FromEventPattern()` and `Observable.ToEventPattern()` methods to turn `View.Touch` event into \"notify only when three fingers are moving\" event (here we\u0027ll call it \"TripleTouch\").\r\n\r\nLet\u0027s begin with a simple application project. After you created one, you will need some using statements for Rx:\r\n\r\n    using System.Reactive;\r\n    using System.Reactive.Linq;\r\n\r\nThe \"TripleTouch\" event is defined and implemented as follows:\r\n\r\n    IEventPatternSource\u003cView.TouchEventArgs\u003e triple_touch_source;\r\n\r\n    public event EventHandler\u003cView.TouchEventArgs\u003e TripleTouch {\r\n\t    add { triple_touch_source.OnNext += value; }\r\n        remove { triple_touch_source.OnNext -= value; }\r\n    }\r\n\r\nThis event is populated when the View is set up. In the simple application sample, I wrote this in the `Activity`\u0027s `OnCreate()`:\r\n\r\n    ...\r\n    // this \"surface\" is the target View here.\r\n    // It can be \"this\" when you implement a custom component.\r\n    var surface = FindViewById\u003cView\u003e (Resource.Id.theToucheable);\r\n\t\r\n    triple_touch_source = Observable.FromEventPattern\u003cView.TouchEventArgs\u003e (surface, \"Touch\")\r\n        .Where (ev =\u003e ev.EventArgs.Event.Action == MotionEventActions.Move)\r\n        .Where (ev =\u003e ev.EventArgs.Event.PointerCount == 3)\r\n        .ToEventPattern ();\r\n\t...\r\n\r\nThen it could be consumed by the `View` users (in the sample, the first line of code is in the `OnCreate()` method):\r\n\r\n    ...\r\n    TripleTouch += (sender, ev) =\u003e this.RunOnUiThread (() =\u003e text.Text = GetEventDescription (ev.Event));\r\n    ...\r\n    \r\n    static string GetEventDescription (MotionEvent e)\r\n    {\r\n        return string.Format (\"({0}, {1})\", e.RawX, e.RawY);\r\n    }\r\n\r\nIn the sample app project, we defined very simple UI in Main.axml:\r\n\r\n    \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n        android:orientation=\"vertical\"\r\n        android:layout_width=\"fill_parent\"\r\n        android:layout_height=\"fill_parent\"\u003e\r\n        \u003cView\r\n            android:id=\"@+id/theToucheable\"\r\n            android:layout_width=\"fill_parent\"\r\n            android:layout_height=\"440.7dp\"\r\n            android:layout_marginBottom=\"0.0dp\" /\u003e\r\n        \u003cTextView\r\n            android:id=\"@+id/theText\"\r\n            android:layout_width=\"fill_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"(touch corrdinates shown here)\" /\u003e\r\n    \u003c/LinearLayout\u003e\r\n\r\nThe sample is all done. Build and run the app on device. Then touch one finger. Nothing happens. Touch with one more finger. Still nothing happens. Add another finger. Then it starts showing the coordinate (of the first finger; this is just a sample so it doesn\u0027t give complicated action).\r\n\r\nWhat implements such behavior? Let\u0027s see the `Observable` part:\r\n\r\n    triple_touch_source = Observable.FromEventPattern\u003cView.TouchEventArgs\u003e (surface, \"Touch\")\r\n\r\nThis converts a `View.Touch` event into an `IObservable`.\r\n\r\n    .Where (ev =\u003e ev.EventArgs.Event.Action == MotionEventActions.Move)\r\n\r\nThis filters out events that are not move events.\r\n\r\n    .Where (ev =\u003e ev.EventArgs.Event.PointerCount == 3)\r\n\r\nThis filters out events that don\u0027t detect three fingers. Now that we have only three-fingered events, we want to convert this observables into another event source:\r\n\r\n    .ToEventPattern ();\r\n\r\nOnce it\u0027s done, we use it to process the actual event. Note that since we are going to control UI, we need to invoke via `RunOnUiThread()`:\r\n\r\n    TripleTouch += (sender, ev) =\u003e this.RunOnUiThread (() =\u003e text.Text = GetEventDescription (ev.Event));\r\n\r\nActually, if you don\u0027t convert the filtered observables into another event, you might want to use `SynchronizationContext` instead (we didn\u0027t do that in this example because having event processing all within the UI thread is not good):\r\n\r\n    (...).SubscribeOn (Android.App.Application.SynchronizationContext) (...)\r\n","Hash":"cdb2049512ef1e9218fc673418065c76","TargetPlatforms":["ios","ios-unified","android"],"TrialHash":null}